name: Build & Push Docker Image

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'scripts/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    if: ${{ github.event_name == 'workflow_dispatch' || !contains(github.event.head_commit.message, '[skip docker]') }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      - name: Update active cloud instances
        if: success()
        env:
          CLOUD_API_URL: ${{ secrets.CLOUD_API_URL }}
          CLOUD_ADMIN_TOKEN: ${{ secrets.CLOUD_ADMIN_TOKEN }}
        run: |
          if [ -z "$CLOUD_API_URL" ] || [ -z "$CLOUD_ADMIN_TOKEN" ]; then
            if [ "$GITHUB_EVENT_NAME" = "push" ] && [ "$GITHUB_REF" = "refs/heads/main" ]; then
              echo "::error::CLOUD_API_URL and CLOUD_ADMIN_TOKEN are required for main pushes"
              exit 1
            fi
            echo "CLOUD_API_URL or CLOUD_ADMIN_TOKEN not set, skipping instance update for non-main run"
            exit 0
          fi
          echo "Updating active cloud instances..."
          response=$(curl -s -w "\n%{http_code}" -X POST \
            "$CLOUD_API_URL/api/cloud/ops/update-machines" \
            -H "Authorization: Bearer $CLOUD_ADMIN_TOKEN" \
            -H "Content-Type: application/json")
          http_code=$(echo "$response" | tail -1)
          body=$(echo "$response" | head -n -1)
          echo "HTTP $http_code: $body"
          if [ "$http_code" -ge 400 ]; then
            echo "::error::Failed to update cloud instances (HTTP $http_code)"
            exit 1
          fi
          BODY="$body" node - <<'NODE'
          const body = process.env.BODY || '{}'
          let payload
          try {
            payload = JSON.parse(body)
          } catch (error) {
            console.error('Invalid JSON from update-machines response:', error.message)
            process.exit(1)
          }
          if ((payload.failed || 0) > 0) {
            console.error(`Update completed with ${payload.failed} failed machine(s)`)
            process.exit(1)
          }
          NODE

      - name: Verify cloud runtime version convergence
        if: success()
        env:
          CLOUD_API_URL: ${{ secrets.CLOUD_API_URL }}
          CLOUD_ADMIN_TOKEN: ${{ secrets.CLOUD_ADMIN_TOKEN }}
        run: |
          if [ -z "$CLOUD_API_URL" ] || [ -z "$CLOUD_ADMIN_TOKEN" ]; then
            if [ "$GITHUB_EVENT_NAME" = "push" ] && [ "$GITHUB_REF" = "refs/heads/main" ]; then
              echo "::error::CLOUD_API_URL and CLOUD_ADMIN_TOKEN are required for main pushes"
              exit 1
            fi
            echo "Skipping runtime convergence verification for non-main run"
            exit 0
          fi
          echo "Checking active runtime versions..."
          response=$(curl -s -w "\n%{http_code}" \
            "$CLOUD_API_URL/api/cloud/ops/runtime-versions" \
            -H "Authorization: Bearer $CLOUD_ADMIN_TOKEN")
          http_code=$(echo "$response" | tail -1)
          body=$(echo "$response" | head -n -1)
          echo "HTTP $http_code: $body"
          if [ "$http_code" -ge 400 ]; then
            echo "::error::Failed to verify runtime versions (HTTP $http_code)"
            exit 1
          fi
          BODY="$body" node - <<'NODE'
          const body = process.env.BODY || '{}'
          let payload
          try {
            payload = JSON.parse(body)
          } catch (error) {
            console.error('Invalid JSON from runtime-versions response:', error.message)
            process.exit(1)
          }
          const behind = Number(payload.behind || 0)
          const unknown = Number(payload.unknown || 0)
          if (unknown > 0) {
            const unknownIds = Array.isArray(payload.instances)
              ? payload.instances.filter((item) => item && !item.runtimeVersion).map((item) => item.id)
              : []
            console.error(`Runtime version unavailable on ${unknown} machine(s): ${unknownIds.join(', ')}`)
            process.exit(1)
          }
          if (behind > 0) {
            const lagging = Array.isArray(payload.instances)
              ? payload.instances.filter((item) => item && item.isBehind).map((item) => item.id)
              : []
            console.error(`Runtime version drift detected on ${behind} machine(s): ${lagging.join(', ')}`)
            process.exit(1)
          }
          NODE
